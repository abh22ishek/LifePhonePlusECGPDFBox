/*
 *
 */
package com.lppbpl;
// Generated by proto2javame, Thu Jul 19 10:18:07 IST 2012.

import net.jarlehansen.protobuf.javame.AbstractOutputWriter;
import net.jarlehansen.protobuf.javame.ComputeSizeUtil;
import net.jarlehansen.protobuf.javame.UninitializedMessageException;
import net.jarlehansen.protobuf.javame.input.DelimitedInputStream;
import net.jarlehansen.protobuf.javame.input.DelimitedSizeUtil;
import net.jarlehansen.protobuf.javame.input.InputReader;
import net.jarlehansen.protobuf.javame.input.taghandler.DefaultUnknownTagHandlerImpl;
import net.jarlehansen.protobuf.javame.input.taghandler.UnknownTagHandler;
import net.jarlehansen.protobuf.javame.output.OutputWriter;

import java.io.IOException;
import java.io.InputStream;

// TODO: Auto-generated Javadoc
/**
 * The Class GetData.
 */
public final class GetData extends AbstractOutputWriter {

	/** The unknown tag handler. */
	private static UnknownTagHandler unknownTagHandler = DefaultUnknownTagHandlerImpl.newInstance();

	/** The measurement type. */
	private final int measurementType;

	/** The Constant fieldNumberMeasurementType. */
	private static final int fieldNumberMeasurementType = 1;

	/** The has measurement type. */
	private final boolean hasMeasurementType;

	/** The query type. */
	private final int queryType;

	/** The Constant fieldNumberQueryType. */
	private static final int fieldNumberQueryType = 2;

	/** The has query type. */
	private final boolean hasQueryType;

	/** The no records. */
	private final int noRecords;

	/** The Constant fieldNumberNoRecords. */
	private static final int fieldNumberNoRecords = 3;

	/** The has no records. */
	private final boolean hasNoRecords;

	/** The start date. */
	private final String startDate;

	/** The Constant fieldNumberStartDate. */
	private static final int fieldNumberStartDate = 4;

	/** The has start date. */
	private final boolean hasStartDate;

	/** The end date. */
	private final String endDate;

	/** The Constant fieldNumberEndDate. */
	private static final int fieldNumberEndDate = 5;

	/** The has end date. */
	private final boolean hasEndDate;

	/** The measurement id. */
	private final int measurementId;

	/** The Constant fieldNumberMeasurementId. */
	private static final int fieldNumberMeasurementId = 6;

	/** The has measurement id. */
	private final boolean hasMeasurementId;

	/** The data type. */
	private final int dataType;

	/** The Constant fieldNumberDataType. */
	private static final int fieldNumberDataType = 7;

	/** The has data type. */
	private final boolean hasDataType;

	/** The prev days. */
	private final int prevDays;

	/** The Constant fieldNumberPrevDays. */
	private static final int fieldNumberPrevDays = 8;

	/** The has prev days. */
	private final boolean hasPrevDays;

	/** The page data. */
	private final PaginationData pageData;

	/** The Constant fieldNumberPageData. */
	private static final int fieldNumberPageData = 20;

	/** The has page data. */
	private final boolean hasPageData;


	/**
	 * Method newBuilder.
	 * @return Builder
	 */
	public static Builder newBuilder() {
		return new Builder();
	}

	/**
	 * Constructor for GetData.
	 * @param builder Builder
	 */
	private GetData(final Builder builder) {
		if (true) {
			this.measurementType = builder.measurementType;
			this.hasMeasurementType = builder.hasMeasurementType;
			this.queryType = builder.queryType;
			this.hasQueryType = builder.hasQueryType;
			this.noRecords = builder.noRecords;
			this.hasNoRecords = builder.hasNoRecords;
			this.startDate = builder.startDate;
			this.hasStartDate = builder.hasStartDate;
			this.endDate = builder.endDate;
			this.hasEndDate = builder.hasEndDate;
			this.measurementId = builder.measurementId;
			this.hasMeasurementId = builder.hasMeasurementId;
			this.dataType = builder.dataType;
			this.hasDataType = builder.hasDataType;
			this.prevDays = builder.prevDays;
			this.hasPrevDays = builder.hasPrevDays;
			this.pageData = builder.pageData;
			this.hasPageData = builder.hasPageData;
		} else {
			throw new UninitializedMessageException("Not all required fields were included (false = not included in message), " +
				"");
		}
	}

	/**
	 * The Class QueryType.
	 */
	public static class QueryType {

		/** The Constant LAST_RECORDS. */
		public static final int LAST_RECORDS = 1;

		/** The Constant BETWEEN_DATES. */
		public static final int BETWEEN_DATES = 2;

		/** The Constant ListQuery. */
		public static final int ListQuery = 3;

		/**
		 * Method getStringValue.
		 * @param value int
		 * @return String
		 */
		public static String getStringValue(int value) {
			String retValue;

			if (value == 1) {
				retValue = "LAST_RECORDS";

			} else if (value == 2) {
				retValue = "BETWEEN_DATES";

			} else if (value == 3) {
				retValue = "ListQuery";

			} else {
				retValue = "";

			}

			return retValue;
		}
	}

	/**
	 * The Class DataType.
	 */

	// Used in AppBaseActivity,SFController,GetActivityTasks
	public static class DataType {

		/** The Constant VersionData. */
		public static final int VersionData = 1;

		/** The Constant SensorData. */
		public static final int SensorData = 2;

		/** The Constant DeviceData. */
		public static final int DeviceData = 3;

		/** The Constant UserData. */
		public static final int UserData = 4;

		/**
		 * Method getStringValue.
		 * @param value int
		 * @return String
		 */
		public static String getStringValue(int value) {
			String retValue;

			switch(value) {
				case 1:
					retValue = "VersionData";
					break;
				case 2:
					retValue = "SensorData";
					break;
				case 3:
					retValue = "DeviceData";
					break;
				case 4:
					retValue = "UserData";
					break;
				default:
					retValue = "";
					break;
			}

			return retValue;
		}
	}

	/**
	 * The Class Builder.
	 */
	public static class Builder {

		/** The measurement type. */
		private int measurementType;

		/** The has measurement type. */
		private boolean hasMeasurementType = false;

		/** The query type. */
		private int queryType;

		/** The has query type. */
		private boolean hasQueryType = false;

		/** The no records. */
		private int noRecords;

		/** The has no records. */
		private boolean hasNoRecords = false;

		/** The start date. */
		private String startDate;

		/** The has start date. */
		private boolean hasStartDate = false;

		/** The end date. */
		private String endDate;

		/** The has end date. */
		private boolean hasEndDate = false;

		/** The measurement id. */
		private int measurementId;

		/** The has measurement id. */
		private boolean hasMeasurementId = false;

		/** The data type. */
		private int dataType;

		/** The has data type. */
		private boolean hasDataType = false;

		/** The prev days. */
		private int prevDays;

		/** The has prev days. */
		private boolean hasPrevDays = false;

		/** The page data. */
		private PaginationData pageData;

		/** The has page data. */
		private boolean hasPageData = false;


		/**
		 * Instantiates a new builder.
		 */
		private Builder() {
		}

		/**
		 * Method setMeasurementType.
		 * @param measurementType int
		 * @return Builder
		 */
		public Builder setMeasurementType(final int measurementType) {
			this.measurementType = measurementType;
			this.hasMeasurementType = true;
			return this;
		}

		/**
		 * Method setQueryType.
		 * @param queryType int
		 * @return Builder
		 */
		public Builder setQueryType(final int queryType) {
			this.queryType = queryType;
			this.hasQueryType = true;
			return this;
		}

		/**
		 * Method setNoRecords.
		 * @param noRecords int
		 * @return Builder
		 */
		public Builder setNoRecords(final int noRecords) {
			this.noRecords = noRecords;
			this.hasNoRecords = true;
			return this;
		}

		/**
		 * Method setStartDate.
		 * @param startDate String
		 * @return Builder
		 */
		public Builder setStartDate(final String startDate) {
			this.startDate = startDate;
			this.hasStartDate = true;
			return this;
		}

		/**
		 * Method setEndDate.
		 * @param endDate String
		 * @return Builder
		 */
		public Builder setEndDate(final String endDate) {
			this.endDate = endDate;
			this.hasEndDate = true;
			return this;
		}

		/**
		 * Method setMeasurementId.
		 * @param measurementId int
		 * @return Builder
		 */
		public Builder setMeasurementId(final int measurementId) {
			this.measurementId = measurementId;
			this.hasMeasurementId = true;
			return this;
		}

		/**
		 * Method setDataType.
		 * @param dataType int
		 * @return Builder
		 */
		// First input to the device
		public Builder setDataType(final int dataType) {
			this.dataType = dataType;
			this.hasDataType = true;
			return this;
		}

		/**
		 * Method setPrevDays.
		 * @param prevDays int
		 * @return Builder
		 */
		public Builder setPrevDays(final int prevDays) {
			this.prevDays = prevDays;
			this.hasPrevDays = true;
			return this;
		}

		/**
		 * Method setPageData.
		 * @param pageData PaginationData
		 * @return Builder
		 */
		public Builder setPageData(final PaginationData pageData) {
			this.pageData = pageData;
			this.hasPageData = true;
			return this;
		}

		/**
		 * Method build.
		 * @return GetData
		 */
		public GetData build() {
			return new GetData(this);
		}
	}

	/**
	 * Method getMeasurementType.
	 * @return int
	 */
	public int getMeasurementType() {
		return measurementType;
	}

	/**
	 * Method hasMeasurementType.
	 * @return boolean
	 */
	public boolean hasMeasurementType() {
		return hasMeasurementType;
	}

	/**
	 * Method getQueryType.
	 * @return int
	 */
	public int getQueryType() {
		return queryType;
	}

	/**
	 * Method hasQueryType.
	 * @return boolean
	 */
	public boolean hasQueryType() {
		return hasQueryType;
	}

	/**
	 * Method getNoRecords.
	 * @return int
	 */
	public int getNoRecords() {
		return noRecords;
	}

	/**
	 * Method hasNoRecords.
	 * @return boolean
	 */
	public boolean hasNoRecords() {
		return hasNoRecords;
	}

	/**
	 * Method getStartDate.
	 * @return String
	 */
	public String getStartDate() {
		return startDate;
	}

	/**
	 * Method hasStartDate.
	 * @return boolean
	 */
	public boolean hasStartDate() {
		return hasStartDate;
	}

	/**
	 * Method getEndDate.
	 * @return String
	 */
	public String getEndDate() {
		return endDate;
	}

	/**
	 * Method hasEndDate.
	 * @return boolean
	 */
	public boolean hasEndDate() {
		return hasEndDate;
	}

	/**
	 * Method getMeasurementId.
	 * @return int
	 */
	public int getMeasurementId() {
		return measurementId;
	}

	/**
	 * Method hasMeasurementId.
	 * @return boolean
	 */
	public boolean hasMeasurementId() {
		return hasMeasurementId;
	}

	/**
	 * Method getDataType.
	 * @return int
	 */
	public int getDataType() {
		return dataType;
	}

	/**
	 * Method hasDataType.
	 * @return boolean
	 */
	public boolean hasDataType() {
		return hasDataType;
	}

	/**
	 * Method getPrevDays.
	 * @return int
	 */
	public int getPrevDays() {
		return prevDays;
	}

	/**
	 * Method hasPrevDays.
	 * @return boolean
	 */
	public boolean hasPrevDays() {
		return hasPrevDays;
	}

	/**
	 * Method getPageData.
	 * @return PaginationData
	 */
	public PaginationData getPageData() {
		return pageData;
	}

	/**
	 * Method hasPageData.
	 * @return boolean
	 */
	public boolean hasPageData() {
		return hasPageData;
	}

	/**
	 * Method toString.
	 * @return String
	 */
	public String toString() {
		final String TAB = "   ";
		String retValue = "";
		retValue += this.getClass().getName() + "(";
		if(hasMeasurementType) retValue += "measurementType = " + this.measurementType + TAB;
		if(hasQueryType) retValue += "queryType = " + this.queryType + TAB;
		if(hasNoRecords) retValue += "noRecords = " + this.noRecords + TAB;
		if(hasStartDate) retValue += "startDate = " + this.startDate + TAB;
		if(hasEndDate) retValue += "endDate = " + this.endDate + TAB;
		if(hasMeasurementId) retValue += "measurementId = " + this.measurementId + TAB;
		if(hasDataType) retValue += "dataType = " + this.dataType + TAB;
		if(hasPrevDays) retValue += "prevDays = " + this.prevDays + TAB;
		if(hasPageData) retValue += "pageData = " + this.pageData + TAB;
		retValue += ")";

		return retValue;
	}

	// Override
	/**
	 * Method computeSize.
	 * @return int
	 * @see net.jarlehansen.protobuf.javame.CustomListWriter#computeSize()
	 */
	public int computeSize() {
		int totalSize = 0;
		if(hasMeasurementType) totalSize += ComputeSizeUtil.computeIntSize(fieldNumberMeasurementType, measurementType);
		if(hasQueryType) totalSize += ComputeSizeUtil.computeIntSize(fieldNumberQueryType, queryType);
		if(hasNoRecords) totalSize += ComputeSizeUtil.computeIntSize(fieldNumberNoRecords, noRecords);
		if(hasStartDate) totalSize += ComputeSizeUtil.computeStringSize(fieldNumberStartDate, startDate);
		if(hasEndDate) totalSize += ComputeSizeUtil.computeStringSize(fieldNumberEndDate, endDate);
		if(hasMeasurementId) totalSize += ComputeSizeUtil.computeIntSize(fieldNumberMeasurementId, measurementId);
		if(hasDataType) totalSize += ComputeSizeUtil.computeIntSize(fieldNumberDataType, dataType);
		if(hasPrevDays) totalSize += ComputeSizeUtil.computeIntSize(fieldNumberPrevDays, prevDays);
		totalSize += computeNestedMessageSize();

		return totalSize;
	}

	/**
	 * Method computeNestedMessageSize.
	 * @return int
	 */
	private int computeNestedMessageSize() {
		int messageSize = 0;
		if(hasPageData) messageSize += ComputeSizeUtil.computeMessageSize(fieldNumberPageData, pageData.computeSize());

		return messageSize;
	}

	// Override
	/**
	 * Method writeFields.
	 *
	 * @param writer OutputWriter
	 * @throws IOException Signals that an I/O exception has occurred.
	 * @see net.jarlehansen.protobuf.javame.CustomListWriter#writeFields(OutputWriter)
	 */
	public void writeFields(final OutputWriter writer) throws IOException {
		if(hasMeasurementType) writer.writeInt(fieldNumberMeasurementType, measurementType);
		if(hasQueryType) writer.writeInt(fieldNumberQueryType, queryType);
		if(hasNoRecords) writer.writeInt(fieldNumberNoRecords, noRecords);
		if(hasStartDate) writer.writeString(fieldNumberStartDate, startDate);
		if(hasEndDate) writer.writeString(fieldNumberEndDate, endDate);
		if(hasMeasurementId) writer.writeInt(fieldNumberMeasurementId, measurementId);
		if(hasDataType) writer.writeInt(fieldNumberDataType, dataType);
		if(hasPrevDays) writer.writeInt(fieldNumberPrevDays, prevDays);
		if(hasPageData) { writer.writeMessage(fieldNumberPageData, pageData.computeSize()); pageData.writeFields(writer); }
	}

	/**
	 * Method parseFields.
	 *
	 * @param reader InputReader
	 * @return GetData
	 * @throws IOException Signals that an I/O exception has occurred.
	 */
	static GetData parseFields(final InputReader reader) throws IOException {
		int nextFieldNumber = getNextFieldNumber(reader);
		final Builder builder = GetData.newBuilder();

		while (nextFieldNumber > 0) {
			if(!populateBuilderWithField(reader, builder, nextFieldNumber)) {
				reader.getPreviousTagDataTypeAndReadContent();
			}
			nextFieldNumber = getNextFieldNumber(reader);
		}

		return builder.build();
	}

	/**
	 * Method getNextFieldNumber.
	 *
	 * @param reader InputReader
	 * @return int
	 * @throws IOException Signals that an I/O exception has occurred.
	 */
	static int getNextFieldNumber(final InputReader reader) throws IOException {
		return reader.getNextFieldNumber();
	}

	/**
	 * Method populateBuilderWithField.
	 *
	 * @param reader InputReader
	 * @param builder Builder
	 * @param fieldNumber int
	 * @return boolean
	 * @throws IOException Signals that an I/O exception has occurred.
	 */
	static boolean populateBuilderWithField(final InputReader reader, final Builder builder, final int fieldNumber) throws IOException {
		boolean fieldFound = true;
		switch (fieldNumber) {
			case fieldNumberMeasurementType:
				builder.setMeasurementType(reader.readInt(fieldNumber));
				break;
			case fieldNumberQueryType:
				builder.setQueryType(reader.readInt(fieldNumber));
				break;
			case fieldNumberNoRecords:
				builder.setNoRecords(reader.readInt(fieldNumber));
				break;
			case fieldNumberStartDate:
				builder.setStartDate(reader.readString(fieldNumber));
				break;
			case fieldNumberEndDate:
				builder.setEndDate(reader.readString(fieldNumber));
				break;
			case fieldNumberMeasurementId:
				builder.setMeasurementId(reader.readInt(fieldNumber));
				break;
			case fieldNumberDataType:
				builder.setDataType(reader.readInt(fieldNumber));
				break;
			case fieldNumberPrevDays:
				builder.setPrevDays(reader.readInt(fieldNumber));
				break;
			case fieldNumberPageData:
				java.util.Vector vcPageData = reader.readMessages(fieldNumberPageData);
				for(int i = 0 ; i < vcPageData.size(); i++) {
					byte[] eachBinData = (byte[]) vcPageData.elementAt(i);
					PaginationData.Builder builderPageData = PaginationData.newBuilder();
					InputReader innerInputReader = new InputReader(eachBinData, unknownTagHandler);
					boolean boolPageData = true;
					int nestedFieldPageData = -1;
					while(boolPageData) {
						nestedFieldPageData = getNextFieldNumber(innerInputReader);
						boolPageData = PaginationData.populateBuilderWithField(innerInputReader, builderPageData, nestedFieldPageData);
					}
					eachBinData = null;
					innerInputReader = null;
					builder.setPageData(builderPageData.build());
				}
				break;
		default:
			fieldFound = false;
		}
		return fieldFound;
	}

	/**
	 * Method setUnknownTagHandler.
	 * @param unknownTagHandler UnknownTagHandler
	 */

	// No use

	public static void setUnknownTagHandler(final UnknownTagHandler unknownTagHandler) {
		GetData.unknownTagHandler = unknownTagHandler;
	}

	/**
	 * Method parseFrom.
	 *
	 * @param data byte[]
	 * @return GetData
	 * @throws IOException Signals that an I/O exception has occurred.
	 */

	// No use

	public static GetData parseFrom(final byte[] data) throws IOException {
		return parseFields(new InputReader(data, unknownTagHandler));
	}

	/**
	 * Method parseFrom.
	 *
	 * @param inputStream InputStream
	 * @return GetData
	 * @throws IOException Signals that an I/O exception has occurred.
	 */

	// No use
	public static GetData parseFrom(final InputStream inputStream) throws IOException {
		return parseFields(new InputReader(inputStream, unknownTagHandler));
	}

	/**
	 * Method parseDelimitedFrom.
	 *
	 * @param inputStream InputStream
	 * @return GetData
	 * @throws IOException Signals that an I/O exception has occurred.
	 */

	// No use
	public static GetData parseDelimitedFrom(final InputStream inputStream) throws IOException {
		final int limit = DelimitedSizeUtil.readDelimitedSize(inputStream);
		return parseFields(new InputReader(new DelimitedInputStream(inputStream, limit), unknownTagHandler));
	}
}